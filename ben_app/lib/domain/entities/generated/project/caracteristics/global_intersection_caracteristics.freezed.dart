// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../../../project/caracteristics/global_intersection_caracteristics.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GlobalIntersectionCaracteristics {
  IntersectionType? get intersectionType => throw _privateConstructorUsedError;
  IntersectionManagement get intersectionManagement =>
      throw _privateConstructorUsedError;
  BikeManagement get bikeManagement => throw _privateConstructorUsedError;
  IntersectionWaythrough get intersectionWaythrough =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GlobalIntersectionCaracteristicsCopyWith<GlobalIntersectionCaracteristics>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GlobalIntersectionCaracteristicsCopyWith<$Res> {
  factory $GlobalIntersectionCaracteristicsCopyWith(
          GlobalIntersectionCaracteristics value,
          $Res Function(GlobalIntersectionCaracteristics) then) =
      _$GlobalIntersectionCaracteristicsCopyWithImpl<$Res,
          GlobalIntersectionCaracteristics>;
  @useResult
  $Res call(
      {IntersectionType? intersectionType,
      IntersectionManagement intersectionManagement,
      BikeManagement bikeManagement,
      IntersectionWaythrough intersectionWaythrough});

  $IntersectionManagementCopyWith<$Res> get intersectionManagement;
  $BikeManagementCopyWith<$Res> get bikeManagement;
  $IntersectionWaythroughCopyWith<$Res> get intersectionWaythrough;
}

/// @nodoc
class _$GlobalIntersectionCaracteristicsCopyWithImpl<$Res,
        $Val extends GlobalIntersectionCaracteristics>
    implements $GlobalIntersectionCaracteristicsCopyWith<$Res> {
  _$GlobalIntersectionCaracteristicsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intersectionType = freezed,
    Object? intersectionManagement = null,
    Object? bikeManagement = null,
    Object? intersectionWaythrough = null,
  }) {
    return _then(_value.copyWith(
      intersectionType: freezed == intersectionType
          ? _value.intersectionType
          : intersectionType // ignore: cast_nullable_to_non_nullable
              as IntersectionType?,
      intersectionManagement: null == intersectionManagement
          ? _value.intersectionManagement
          : intersectionManagement // ignore: cast_nullable_to_non_nullable
              as IntersectionManagement,
      bikeManagement: null == bikeManagement
          ? _value.bikeManagement
          : bikeManagement // ignore: cast_nullable_to_non_nullable
              as BikeManagement,
      intersectionWaythrough: null == intersectionWaythrough
          ? _value.intersectionWaythrough
          : intersectionWaythrough // ignore: cast_nullable_to_non_nullable
              as IntersectionWaythrough,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IntersectionManagementCopyWith<$Res> get intersectionManagement {
    return $IntersectionManagementCopyWith<$Res>(_value.intersectionManagement,
        (value) {
      return _then(_value.copyWith(intersectionManagement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $BikeManagementCopyWith<$Res> get bikeManagement {
    return $BikeManagementCopyWith<$Res>(_value.bikeManagement, (value) {
      return _then(_value.copyWith(bikeManagement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IntersectionWaythroughCopyWith<$Res> get intersectionWaythrough {
    return $IntersectionWaythroughCopyWith<$Res>(_value.intersectionWaythrough,
        (value) {
      return _then(_value.copyWith(intersectionWaythrough: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GlobalIntersectionCaracteristicsImplCopyWith<$Res>
    implements $GlobalIntersectionCaracteristicsCopyWith<$Res> {
  factory _$$GlobalIntersectionCaracteristicsImplCopyWith(
          _$GlobalIntersectionCaracteristicsImpl value,
          $Res Function(_$GlobalIntersectionCaracteristicsImpl) then) =
      __$$GlobalIntersectionCaracteristicsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {IntersectionType? intersectionType,
      IntersectionManagement intersectionManagement,
      BikeManagement bikeManagement,
      IntersectionWaythrough intersectionWaythrough});

  @override
  $IntersectionManagementCopyWith<$Res> get intersectionManagement;
  @override
  $BikeManagementCopyWith<$Res> get bikeManagement;
  @override
  $IntersectionWaythroughCopyWith<$Res> get intersectionWaythrough;
}

/// @nodoc
class __$$GlobalIntersectionCaracteristicsImplCopyWithImpl<$Res>
    extends _$GlobalIntersectionCaracteristicsCopyWithImpl<$Res,
        _$GlobalIntersectionCaracteristicsImpl>
    implements _$$GlobalIntersectionCaracteristicsImplCopyWith<$Res> {
  __$$GlobalIntersectionCaracteristicsImplCopyWithImpl(
      _$GlobalIntersectionCaracteristicsImpl _value,
      $Res Function(_$GlobalIntersectionCaracteristicsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intersectionType = freezed,
    Object? intersectionManagement = null,
    Object? bikeManagement = null,
    Object? intersectionWaythrough = null,
  }) {
    return _then(_$GlobalIntersectionCaracteristicsImpl(
      intersectionType: freezed == intersectionType
          ? _value.intersectionType
          : intersectionType // ignore: cast_nullable_to_non_nullable
              as IntersectionType?,
      intersectionManagement: null == intersectionManagement
          ? _value.intersectionManagement
          : intersectionManagement // ignore: cast_nullable_to_non_nullable
              as IntersectionManagement,
      bikeManagement: null == bikeManagement
          ? _value.bikeManagement
          : bikeManagement // ignore: cast_nullable_to_non_nullable
              as BikeManagement,
      intersectionWaythrough: null == intersectionWaythrough
          ? _value.intersectionWaythrough
          : intersectionWaythrough // ignore: cast_nullable_to_non_nullable
              as IntersectionWaythrough,
    ));
  }
}

/// @nodoc

class _$GlobalIntersectionCaracteristicsImpl
    implements _GlobalIntersectionCaracteristics {
  const _$GlobalIntersectionCaracteristicsImpl(
      {this.intersectionType,
      required this.intersectionManagement,
      required this.bikeManagement,
      required this.intersectionWaythrough});

  @override
  final IntersectionType? intersectionType;
  @override
  final IntersectionManagement intersectionManagement;
  @override
  final BikeManagement bikeManagement;
  @override
  final IntersectionWaythrough intersectionWaythrough;

  @override
  String toString() {
    return 'GlobalIntersectionCaracteristics(intersectionType: $intersectionType, intersectionManagement: $intersectionManagement, bikeManagement: $bikeManagement, intersectionWaythrough: $intersectionWaythrough)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GlobalIntersectionCaracteristicsImpl &&
            (identical(other.intersectionType, intersectionType) ||
                other.intersectionType == intersectionType) &&
            (identical(other.intersectionManagement, intersectionManagement) ||
                other.intersectionManagement == intersectionManagement) &&
            (identical(other.bikeManagement, bikeManagement) ||
                other.bikeManagement == bikeManagement) &&
            (identical(other.intersectionWaythrough, intersectionWaythrough) ||
                other.intersectionWaythrough == intersectionWaythrough));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intersectionType,
      intersectionManagement, bikeManagement, intersectionWaythrough);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GlobalIntersectionCaracteristicsImplCopyWith<
          _$GlobalIntersectionCaracteristicsImpl>
      get copyWith => __$$GlobalIntersectionCaracteristicsImplCopyWithImpl<
          _$GlobalIntersectionCaracteristicsImpl>(this, _$identity);
}

abstract class _GlobalIntersectionCaracteristics
    implements GlobalIntersectionCaracteristics {
  const factory _GlobalIntersectionCaracteristics(
          {final IntersectionType? intersectionType,
          required final IntersectionManagement intersectionManagement,
          required final BikeManagement bikeManagement,
          required final IntersectionWaythrough intersectionWaythrough}) =
      _$GlobalIntersectionCaracteristicsImpl;

  @override
  IntersectionType? get intersectionType;
  @override
  IntersectionManagement get intersectionManagement;
  @override
  BikeManagement get bikeManagement;
  @override
  IntersectionWaythrough get intersectionWaythrough;
  @override
  @JsonKey(ignore: true)
  _$$GlobalIntersectionCaracteristicsImplCopyWith<
          _$GlobalIntersectionCaracteristicsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$IntersectionManagement {
  bool get giveWay => throw _privateConstructorUsedError;
  bool get stop => throw _privateConstructorUsedError;
  bool get trafficLights => throw _privateConstructorUsedError;
  bool get rightPriority => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $IntersectionManagementCopyWith<IntersectionManagement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntersectionManagementCopyWith<$Res> {
  factory $IntersectionManagementCopyWith(IntersectionManagement value,
          $Res Function(IntersectionManagement) then) =
      _$IntersectionManagementCopyWithImpl<$Res, IntersectionManagement>;
  @useResult
  $Res call({bool giveWay, bool stop, bool trafficLights, bool rightPriority});
}

/// @nodoc
class _$IntersectionManagementCopyWithImpl<$Res,
        $Val extends IntersectionManagement>
    implements $IntersectionManagementCopyWith<$Res> {
  _$IntersectionManagementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? giveWay = null,
    Object? stop = null,
    Object? trafficLights = null,
    Object? rightPriority = null,
  }) {
    return _then(_value.copyWith(
      giveWay: null == giveWay
          ? _value.giveWay
          : giveWay // ignore: cast_nullable_to_non_nullable
              as bool,
      stop: null == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as bool,
      trafficLights: null == trafficLights
          ? _value.trafficLights
          : trafficLights // ignore: cast_nullable_to_non_nullable
              as bool,
      rightPriority: null == rightPriority
          ? _value.rightPriority
          : rightPriority // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IntersectionManagementImplCopyWith<$Res>
    implements $IntersectionManagementCopyWith<$Res> {
  factory _$$IntersectionManagementImplCopyWith(
          _$IntersectionManagementImpl value,
          $Res Function(_$IntersectionManagementImpl) then) =
      __$$IntersectionManagementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool giveWay, bool stop, bool trafficLights, bool rightPriority});
}

/// @nodoc
class __$$IntersectionManagementImplCopyWithImpl<$Res>
    extends _$IntersectionManagementCopyWithImpl<$Res,
        _$IntersectionManagementImpl>
    implements _$$IntersectionManagementImplCopyWith<$Res> {
  __$$IntersectionManagementImplCopyWithImpl(
      _$IntersectionManagementImpl _value,
      $Res Function(_$IntersectionManagementImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? giveWay = null,
    Object? stop = null,
    Object? trafficLights = null,
    Object? rightPriority = null,
  }) {
    return _then(_$IntersectionManagementImpl(
      giveWay: null == giveWay
          ? _value.giveWay
          : giveWay // ignore: cast_nullable_to_non_nullable
              as bool,
      stop: null == stop
          ? _value.stop
          : stop // ignore: cast_nullable_to_non_nullable
              as bool,
      trafficLights: null == trafficLights
          ? _value.trafficLights
          : trafficLights // ignore: cast_nullable_to_non_nullable
              as bool,
      rightPriority: null == rightPriority
          ? _value.rightPriority
          : rightPriority // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$IntersectionManagementImpl implements _IntersectionManagement {
  const _$IntersectionManagementImpl(
      {required this.giveWay,
      required this.stop,
      required this.trafficLights,
      required this.rightPriority});

  @override
  final bool giveWay;
  @override
  final bool stop;
  @override
  final bool trafficLights;
  @override
  final bool rightPriority;

  @override
  String toString() {
    return 'IntersectionManagement(giveWay: $giveWay, stop: $stop, trafficLights: $trafficLights, rightPriority: $rightPriority)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IntersectionManagementImpl &&
            (identical(other.giveWay, giveWay) || other.giveWay == giveWay) &&
            (identical(other.stop, stop) || other.stop == stop) &&
            (identical(other.trafficLights, trafficLights) ||
                other.trafficLights == trafficLights) &&
            (identical(other.rightPriority, rightPriority) ||
                other.rightPriority == rightPriority));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, giveWay, stop, trafficLights, rightPriority);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IntersectionManagementImplCopyWith<_$IntersectionManagementImpl>
      get copyWith => __$$IntersectionManagementImplCopyWithImpl<
          _$IntersectionManagementImpl>(this, _$identity);
}

abstract class _IntersectionManagement implements IntersectionManagement {
  const factory _IntersectionManagement(
      {required final bool giveWay,
      required final bool stop,
      required final bool trafficLights,
      required final bool rightPriority}) = _$IntersectionManagementImpl;

  @override
  bool get giveWay;
  @override
  bool get stop;
  @override
  bool get trafficLights;
  @override
  bool get rightPriority;
  @override
  @JsonKey(ignore: true)
  _$$IntersectionManagementImplCopyWith<_$IntersectionManagementImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BikeManagement {
  bool get bikeSpace => throw _privateConstructorUsedError;
  bool get bikeGiveway => throw _privateConstructorUsedError;
  bool get other => throw _privateConstructorUsedError;
  String? get comment => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BikeManagementCopyWith<BikeManagement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BikeManagementCopyWith<$Res> {
  factory $BikeManagementCopyWith(
          BikeManagement value, $Res Function(BikeManagement) then) =
      _$BikeManagementCopyWithImpl<$Res, BikeManagement>;
  @useResult
  $Res call({bool bikeSpace, bool bikeGiveway, bool other, String? comment});
}

/// @nodoc
class _$BikeManagementCopyWithImpl<$Res, $Val extends BikeManagement>
    implements $BikeManagementCopyWith<$Res> {
  _$BikeManagementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bikeSpace = null,
    Object? bikeGiveway = null,
    Object? other = null,
    Object? comment = freezed,
  }) {
    return _then(_value.copyWith(
      bikeSpace: null == bikeSpace
          ? _value.bikeSpace
          : bikeSpace // ignore: cast_nullable_to_non_nullable
              as bool,
      bikeGiveway: null == bikeGiveway
          ? _value.bikeGiveway
          : bikeGiveway // ignore: cast_nullable_to_non_nullable
              as bool,
      other: null == other
          ? _value.other
          : other // ignore: cast_nullable_to_non_nullable
              as bool,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BikeManagementImplCopyWith<$Res>
    implements $BikeManagementCopyWith<$Res> {
  factory _$$BikeManagementImplCopyWith(_$BikeManagementImpl value,
          $Res Function(_$BikeManagementImpl) then) =
      __$$BikeManagementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool bikeSpace, bool bikeGiveway, bool other, String? comment});
}

/// @nodoc
class __$$BikeManagementImplCopyWithImpl<$Res>
    extends _$BikeManagementCopyWithImpl<$Res, _$BikeManagementImpl>
    implements _$$BikeManagementImplCopyWith<$Res> {
  __$$BikeManagementImplCopyWithImpl(
      _$BikeManagementImpl _value, $Res Function(_$BikeManagementImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bikeSpace = null,
    Object? bikeGiveway = null,
    Object? other = null,
    Object? comment = freezed,
  }) {
    return _then(_$BikeManagementImpl(
      bikeSpace: null == bikeSpace
          ? _value.bikeSpace
          : bikeSpace // ignore: cast_nullable_to_non_nullable
              as bool,
      bikeGiveway: null == bikeGiveway
          ? _value.bikeGiveway
          : bikeGiveway // ignore: cast_nullable_to_non_nullable
              as bool,
      other: null == other
          ? _value.other
          : other // ignore: cast_nullable_to_non_nullable
              as bool,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BikeManagementImpl implements _BikeManagement {
  const _$BikeManagementImpl(
      {required this.bikeSpace,
      required this.bikeGiveway,
      required this.other,
      this.comment});

  @override
  final bool bikeSpace;
  @override
  final bool bikeGiveway;
  @override
  final bool other;
  @override
  final String? comment;

  @override
  String toString() {
    return 'BikeManagement(bikeSpace: $bikeSpace, bikeGiveway: $bikeGiveway, other: $other, comment: $comment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BikeManagementImpl &&
            (identical(other.bikeSpace, bikeSpace) ||
                other.bikeSpace == bikeSpace) &&
            (identical(other.bikeGiveway, bikeGiveway) ||
                other.bikeGiveway == bikeGiveway) &&
            (identical(other.other, this.other) || other.other == this.other) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, bikeSpace, bikeGiveway, other, comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BikeManagementImplCopyWith<_$BikeManagementImpl> get copyWith =>
      __$$BikeManagementImplCopyWithImpl<_$BikeManagementImpl>(
          this, _$identity);
}

abstract class _BikeManagement implements BikeManagement {
  const factory _BikeManagement(
      {required final bool bikeSpace,
      required final bool bikeGiveway,
      required final bool other,
      final String? comment}) = _$BikeManagementImpl;

  @override
  bool get bikeSpace;
  @override
  bool get bikeGiveway;
  @override
  bool get other;
  @override
  String? get comment;
  @override
  @JsonKey(ignore: true)
  _$$BikeManagementImplCopyWith<_$BikeManagementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$IntersectionWaythrough {
  bool get specificWaythrough => throw _privateConstructorUsedError;
  bool get walkwayWaythrough => throw _privateConstructorUsedError;
  bool get none => throw _privateConstructorUsedError;
  bool get other => throw _privateConstructorUsedError;
  String? get comment => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $IntersectionWaythroughCopyWith<IntersectionWaythrough> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntersectionWaythroughCopyWith<$Res> {
  factory $IntersectionWaythroughCopyWith(IntersectionWaythrough value,
          $Res Function(IntersectionWaythrough) then) =
      _$IntersectionWaythroughCopyWithImpl<$Res, IntersectionWaythrough>;
  @useResult
  $Res call(
      {bool specificWaythrough,
      bool walkwayWaythrough,
      bool none,
      bool other,
      String? comment});
}

/// @nodoc
class _$IntersectionWaythroughCopyWithImpl<$Res,
        $Val extends IntersectionWaythrough>
    implements $IntersectionWaythroughCopyWith<$Res> {
  _$IntersectionWaythroughCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? specificWaythrough = null,
    Object? walkwayWaythrough = null,
    Object? none = null,
    Object? other = null,
    Object? comment = freezed,
  }) {
    return _then(_value.copyWith(
      specificWaythrough: null == specificWaythrough
          ? _value.specificWaythrough
          : specificWaythrough // ignore: cast_nullable_to_non_nullable
              as bool,
      walkwayWaythrough: null == walkwayWaythrough
          ? _value.walkwayWaythrough
          : walkwayWaythrough // ignore: cast_nullable_to_non_nullable
              as bool,
      none: null == none
          ? _value.none
          : none // ignore: cast_nullable_to_non_nullable
              as bool,
      other: null == other
          ? _value.other
          : other // ignore: cast_nullable_to_non_nullable
              as bool,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IntersectionWaythroughImplCopyWith<$Res>
    implements $IntersectionWaythroughCopyWith<$Res> {
  factory _$$IntersectionWaythroughImplCopyWith(
          _$IntersectionWaythroughImpl value,
          $Res Function(_$IntersectionWaythroughImpl) then) =
      __$$IntersectionWaythroughImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool specificWaythrough,
      bool walkwayWaythrough,
      bool none,
      bool other,
      String? comment});
}

/// @nodoc
class __$$IntersectionWaythroughImplCopyWithImpl<$Res>
    extends _$IntersectionWaythroughCopyWithImpl<$Res,
        _$IntersectionWaythroughImpl>
    implements _$$IntersectionWaythroughImplCopyWith<$Res> {
  __$$IntersectionWaythroughImplCopyWithImpl(
      _$IntersectionWaythroughImpl _value,
      $Res Function(_$IntersectionWaythroughImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? specificWaythrough = null,
    Object? walkwayWaythrough = null,
    Object? none = null,
    Object? other = null,
    Object? comment = freezed,
  }) {
    return _then(_$IntersectionWaythroughImpl(
      specificWaythrough: null == specificWaythrough
          ? _value.specificWaythrough
          : specificWaythrough // ignore: cast_nullable_to_non_nullable
              as bool,
      walkwayWaythrough: null == walkwayWaythrough
          ? _value.walkwayWaythrough
          : walkwayWaythrough // ignore: cast_nullable_to_non_nullable
              as bool,
      none: null == none
          ? _value.none
          : none // ignore: cast_nullable_to_non_nullable
              as bool,
      other: null == other
          ? _value.other
          : other // ignore: cast_nullable_to_non_nullable
              as bool,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$IntersectionWaythroughImpl implements _IntersectionWaythrough {
  const _$IntersectionWaythroughImpl(
      {required this.specificWaythrough,
      required this.walkwayWaythrough,
      required this.none,
      required this.other,
      this.comment});

  @override
  final bool specificWaythrough;
  @override
  final bool walkwayWaythrough;
  @override
  final bool none;
  @override
  final bool other;
  @override
  final String? comment;

  @override
  String toString() {
    return 'IntersectionWaythrough(specificWaythrough: $specificWaythrough, walkwayWaythrough: $walkwayWaythrough, none: $none, other: $other, comment: $comment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IntersectionWaythroughImpl &&
            (identical(other.specificWaythrough, specificWaythrough) ||
                other.specificWaythrough == specificWaythrough) &&
            (identical(other.walkwayWaythrough, walkwayWaythrough) ||
                other.walkwayWaythrough == walkwayWaythrough) &&
            (identical(other.none, none) || other.none == none) &&
            (identical(other.other, this.other) || other.other == this.other) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, specificWaythrough, walkwayWaythrough, none, other, comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IntersectionWaythroughImplCopyWith<_$IntersectionWaythroughImpl>
      get copyWith => __$$IntersectionWaythroughImplCopyWithImpl<
          _$IntersectionWaythroughImpl>(this, _$identity);
}

abstract class _IntersectionWaythrough implements IntersectionWaythrough {
  const factory _IntersectionWaythrough(
      {required final bool specificWaythrough,
      required final bool walkwayWaythrough,
      required final bool none,
      required final bool other,
      final String? comment}) = _$IntersectionWaythroughImpl;

  @override
  bool get specificWaythrough;
  @override
  bool get walkwayWaythrough;
  @override
  bool get none;
  @override
  bool get other;
  @override
  String? get comment;
  @override
  @JsonKey(ignore: true)
  _$$IntersectionWaythroughImplCopyWith<_$IntersectionWaythroughImpl>
      get copyWith => throw _privateConstructorUsedError;
}
